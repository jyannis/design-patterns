Java设计模式之观察者模式：
    Description:
    定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。

    优点:
     具体主题和具体观察者是松耦合关系。由于主题接口仅仅依赖于观察者接口，因此具体主题只是知道它的观察者是实现观察者接口的某个类的实例，但不需要知道具体是哪个类。同样，由于观察者仅仅依赖于主题接口，因此具体观察者只是知道它依赖的主题是实现主题接口的某个类的实例，但不需要知道具体是哪个类；
     观察者模式满足“开-闭原则”。主题接口仅仅依赖于观察者接口，这样，就可以让创建具体主题的类也仅仅是依赖于观察者接口，因此，如果增加新的实现观察者接口的类，不必修改创建具体主题的类的代码。同样，创建具体观察者的类仅仅依赖于主题接口，如果增加新的实现主题接口的类，也不必修改创建具体观察者类的代码。

    缺点:
     如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间；
     如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃；
     观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。

    适用场景:
     当一个抽象模型有两个方面，其中一个方面依赖于另一个方面。
     当对一个对象的改变需要同时改变其它对象，而不知道具体有多少个对象待改变。
     当一个对象必须通知其它对象，而它又不能假定其它对象是谁。换句话说，你不希望这些对象是紧密耦合的。

    体现的设计原则:
     为了交互对象之间的松耦合设计而努力；
     将程序中会变化的方面和固定不变的方面相分离；
     多用组合，少用继承；
     针对接口编程，不针对实现编程；

    JDK中对观察者模式的运用：
     Swing(ActionListener按钮监听事件)
     JavaBeans(PropertyChangeListener接口)

本实例：
    观察者模式：
        抽象主题：Subject接口
        抽象观察者：Observer接口
        具体主题：Teacher类
        具体观察者：StudentA类，StudentB类
    含义：老师发通知，学生A和学生B收到通知